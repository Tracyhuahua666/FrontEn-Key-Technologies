# JavaScript上下文，作用域链，闭包

在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用arguments和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。

在某个内部函数的执行上下文创建时，会将父级函数的活动对象加到内部函数的 [[scope]] 中，形成作用域链，所以即使父级函数的执行上下文销毁（即执行上下文栈弹出父级函数的执行上下文），但是因为其活动对象还是实际存储在内存中可被内部函数访问到的，从而实现了闭包。


## JavaScript上下文的创建

### 1.确定this
在全局执行上下文中，this总是指向全局对象，在函数执行上下文中，this一般指向调用函数的对象
### 2.创建变量对象
arguments对象和其它变量
### 3.创建作用域链
执行环境上下文中的作用域链，是由当前内存中各个变量对象串起来的单向链表，每入栈执行一个function，其对应的变量对象就添加到作用域链的头部，前一个变量对象能自由访问到下一个变量对象上的变量，反过来就不行。

## 上下文的执行

函数执行上下文可存在无数个，每当一个函数被调用时都会创建一个函数上下文；，同一个函数被多次调用，都会创建一个新的上下文。

JS代码首次运行，都会先创建一个全局执行上下文并压入到执行栈中，之后每当有函数被调用，都会创建一个新的函数执行上下文并压入栈内；由于执行栈LIFO的特性，所以可以理解为，JS代码执行完毕前在执行栈底部永远有个全局执行上下文。
