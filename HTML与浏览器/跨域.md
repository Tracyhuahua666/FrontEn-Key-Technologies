## 跨域原因：

协议，域名，端口号任意一个不一致，都会导致跨域

## 跨域本质：

跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。

## 为什么表单可以发跨域请求：

因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。

## 跨域解决方案：

### JSONP：

原理：利用 script 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。

优缺点：JSONP 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持 get 方法具有局限性,不安全可能会遭受 XSS 攻击。

### CORS

对于简单请求和复杂请求，有不同的跨域方案

```
请求方法是以下方三种方法之一

HEAD
GET
POST

HTTP 的头信息不超出以下几种字段

Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain
```

简单请求的跨域（需要后端的配合）：

1.浏览器在请求头信息中增加一个 origin 字段，说明本次请求来自哪个源,服务器根据这个值,决定是否同意这次请求。
2.1 服务端在 response header 中，增加以下字段，向浏览器表明可以跨域：
Access-Control-Allow-Origin： 这个字段是必须的,表示接受那些域名的请求(\*表示所有)
Access-Control-Allow-Credentials 该字段可选, 表示是否可以发送 cookie
2.2 若服务端不接受跨域，就不返回上述字段，浏览器就得知不能跨域

复杂请求的跨域（也是需要后端的配合）：

1.会在正式通信之前，增加一次 HTTP 查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。

2.预检请求后的回应，服务器收到"预检"请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以做出回应。

3.浏览器根据预检的响应头判断是否允许跨域。

4.当预检请求通过之后发出正经的 HTTP 请求,还有一个就是一旦通过了预检请求就会,请求的时候就会跟简单请求,会有一个 Origin 头信息字段。

### Nginx 转发

实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。

为什么 nginx 访问 domain2 不会跨域？
因为跨域是浏览器的安全限制，nginx 不是浏览器，就不会跨域。
